=head1 NAME

List::Ish - List object

=head1 SYNOPSIS

  my $array_ref = [
    {name => 'jkondo'},
    {name => 'cinnamon'}
  ];
  my $list = List::Ish->new($array_ref);

  $list->length;            #=> 2
  my $first = $list->shift; #=> {name => 'jkondo'}
  $list->push($first);      #=> [{name => 'cinnamon'}, {name => 'jkondo'}];

  # List::Ish provides much more useful methods. For more
  # details, see the sections below.

=head1 DESCRIPTION

The C<List::Ish> module provides a class for handling a list (or
array) as an object.

=head1 CONSTRUCTOR

=over 4

=item $list = List::Ish->new ([$item1, $item2, ...])

Construct a list object.  The argument to the C<new> method must be an
array reference.  The reference is blessed by the L<List::Ish> class
(or its subclass), even if it has been blessed by another class.

=back

=head1 @{}

Since a L<List::Ish> object is just a blessed array reference, you can
treat is as an array reference in most cases, like:

  my $list = List::Ish->new ([...]);
  for (@$list) {
    ...
  }
  warn $list->[2];

=head1 CLASS METHODS

In addition to just treating the list object as an array reference,
following methods are available to the list object:

=over 4

=item push ( I<@array> )

=item unshift ( I<@array> )

Sets the argument into C<$self>, a refernce to an array blessed by
List::Ish, like the same name functions provided by Perl core,
then returns a List::Ish object.

  my $list = List::Ish->new([qw(1 2 3)]);
  $list->push(4, 5); #=> [1, 2, 3, 4, 5]
  $list->unshift(0); #=> [0, 1, 2, 3, 4, 5]

=item append ( I<\@array> )

=item prepend ( I<\@array> )

They're almost the same as C<push()>/C<unshift()> described above
except that the argument shoud be a reference to an array.

  my $list = List::Ish->new([1, 2, 3]);
  $list->append([4, 5]); #=> [1, 2, 3, 4, 5]
  $list->prepend([0]);   #=> [0, 1, 2, 3, 4, 5]

=item shift ()

=item pop ()

Pulls out the first/last element from C<$self>, a refernce to an array
blessed by List::Ish, then returns it like the same name
functions in Perl core.

  $list = List::Ish->new([1, 2, 3]);
  $list->shift; #=> 1
  $list->pop;   #=> 3
  $list->dump   #=> [2]

=item first ()

=item last ()

Returns the first/last element of C<$self>, a refernce to an array
blessed by List::Ish. These methods aren't destructive contrary
to C<shift()>/C<pop()> method.

  $list = List::Ish->new([1, 2, 3]);
  $list->first; #=> 1
  $list->last;  #=> 3
  $list->dump   #=> [1, 2, 3]

=item slice ( I<$start>, I<$end> )

Returns the elements whose indexes are between C<$start> and C<$end>
as a new L<List::Ish> object.

  $list = List::Ish->new([qw(1 2 3 4)]);
  $list->slice(1, 2) #=> [2, 3]

=item join ( I<$delimiter> )

Joins all the elements by C<$delimiter>.

  $list = List::Ish->new([0 1 2 3]);
  $list->join(', ') #=> '0, 1, 2, 3'

=item each ( I<$code> )

Executes C<$code> with each value of C<$self>, a refernce to an array
blessed by List::Ish.

  $list = List::Ish->new([1, 2, 3]);
  $list->each(sub { do_something($_) });

=item map ( I<$code> )

Executes C<$code> with each element of C<$self>, a refernce to an
array blessed by List::Ish using CORE::map() and returns the results
as a new L<List::Ish> object.

  $list = List::Ish->new([1, 2, 3]);
  $list->map(sub { $_ * 2 }); #=> [2, 4, 6]

=item grep ( I<$code> )

Executes C<$code> with each element of C<$self>, a refernce to an
array blessed by List::Ish using CORE::grep() and returns the results
as a new L<List::Ish> object.

  $list = List::Ish->new([qw(1 2 3 4)]);
  $list->grep(sub { ($_ % 2) == 0 }); #=> [2, 4]

=item uniq_by ( I<$code> )

Returns a new list that does contain the items in the list in order,
without any duplication.  Whether an item is duplicated or not is
determined by the code reference given as the argument.

The code reference receives two items as the arguments.  It is
expected for the code to return whether they are equal or not for the
purpose of removal of duplications.  It is expected that the
transitivity rule is applicable for the equivalence.  The code may
throw an exception if desired.

  $list = List::Ish->new([qw(1 2 4 3)]);
  $list = $list->uniq_by(sub { ($_[0] % 3) == ($_[1] % 3) });
  warn $list->join(' '); #=> 1 2 3

=item uniq_by_key ( I<$code> )

Returns a new list that does contain the items in the list in order,
without any duplication.  Whether an item is duplicated or not is
determined by the key generated by the code reference given as the
argument.

The code reference receives an item as C<$_>.  It is expected for the
code to return a string that is obtained from the item.  Then the
duplication is determined based on the literal equality of the string.
The code may throw an exception if desired.

  $list = List::Ish->new([[1, 2], [4, 2], [2, 4], [3, 3], [0, 10]]);
  $list = $list->uniq_by_key(sub { $_->[0] + $_->[1] });
  warn $list->map(sub { $_->[0] + $_->[1] })
      ->join(' '); #=> 3 6 10

=item find ( I<$code> )

Returns the first value found in C<$self>, a refernce to an array
blessed by List::Ish, as a result of C<$code>.

  $list = List::Ish->new([1, 2, 3, 4]);
  $list->find(sub { ($_ % 2) == 0 }); #=> 2

Be careful to use this method if the list can contain false values,
such as C<undef>, zero, and the empty string.  Testing whether the
C<find> method returns true or not is not equivalent to testing
whether there is a value matching the specified condition or not in
those cases.

=item has ( I<$code> )

Returns whether there is one or more list items that matches the
specified condition or not.  The code reference specified as the
argument is invoked with each item in the list, with the C<$_>
variable set to the list item, until the code reference returns true.
The code reference is expected to return whether the list item matches
the desired condition or not.  The code reference may throw an
exception, if desired.  Otherwise, the method return a boolean value,
representing whether there is at least one item that matches the
specified condition or not.

Unlike the C<find> method, this method would return a true value if
the code reference returns a true value, even if the list item was a
false value.

  $list = List::Ish->new([1, undef, 0, 10]);
  ok $list->has(sub { defined $_ and $_ < 1 }); #=> true

=item sort ( I<$code> )

Sorts out each element and returns the result as a new L<List::Ish>
object.

  $list = List::Ish->new([qw(3 2 4 1]);
  $list->sort;                          #=> [1, 2, 3, 4]
  $list->sort(sub { $_[1] <=> $_[0] }); #=> [4, 3, 2, 1]

=item length ()

Returns the length of C<$self>, a refernce to an array blessed by
List::Ish.

  $list = List::Ish->new([qw(1 2 3 4)]);
  $list->length; #=> 4

This method is equivalent to C<scalar @{$list}> or C<length @{$list}>.

=item size ()

An alias of C<length()> method described above.

=item reverse ()

Returns an reversely ordered C<$self>, a refernce to an array blessed
by List::Ish.

  $list = List::Ish->new([4, 1, 3, 2])
  $list->reverse; #=> [2, 3, 1, 4]

=item clone ()

Returns a duplicated C<$self>, a refernce to an array blessed by
List::Ish.

=item dup ()

An alias of the C<clone> method.

=item to_a ()

Returns a duplication of the list, without blessing.  In other word,
the method returns an array reference that contains the items of the
list, in the same order.

  $arrayref = $list->to_a;
  is ref $arrayref, 'ARRAY';

=item to_list ()

Returns a Perl list containing the items of the list, in the same
order.

  @list = $list->to_list;

This method is equivalent to the C<@$list> operation in the list
context.

=item as_hashref ()

Returns a hash reference that contains key/value pairs where the keys
are the stringified representations of the items in the list and the
values are C<1>.

  $list = List::Ish->new([1, 2, 3]);
  $hashref = $list->as_hashref;
  eq_or_diff [sort keys %$hashref], [1, 2, 3];

=back

=head1 HISTORY

=over 4

=item 0.04 (2012-01-01)

First revision.

=back

=head1 ACKNOWLEDGEMENTS

The L<List::Ish> module derived from L<List::Rubyish>, which is
available at
<http://svn.coderepos.org/share/lang/perl/List-Rubyish/trunk> or
<http://search.cpan.org/dist/List-Rubyish/>.

The L<List::Rubyish> module is inspired by, or in fact derived from,
various list-related modules, including: L<DBIx::MoCo::List>,
L<List::Util>, L<List::MoreUtils>,
L<http://github.com/naoya/list-rubylike>,
L<http://d.hatena.ne.jp/naoya/20080419/1208579525>, and
L<http://www.ruby-lang.org/ja/man/html/Enumerable.html>.

Authors of L<List::Rubyish> are: Junya Kondo,
E<lt>jkondo@hatena.comE<gt>, Naoya Ito, E<lt>naoya@hatena.ne.jpE<gt>,
Kentaro Kuribayashi, E<lt>kentarok@gmail.comE<gt>, Yuichi Tateno,
E<lt>secondlife at hatena ne jp<gt>, and Kazuhiro Osawa E<lt>yappo
<at> shibuya <dÃ¶t> plE<gt>.  They acknowledge naoya, kentaro,
tokuhirom, kan, and lopnor for their contributions.

=head1 AUTHOR

Wakaba <w@suika.fam.cx>.

=head1 LICENSE

Copyright (C) Hatena Inc. All Rights Reserved.

Copyright 2009-2011 Hatena <http://www.hatena.com/>.

Copyright 2012 Wakaba <w@suika.fam.cx>.

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.

=cut
